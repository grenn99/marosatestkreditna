import React, { useState, useEffect, useCallback } from 'react';
import { useCart } from '../context/CartContext';
import { useTranslation } from 'react-i18next';
import { useNavigate } from 'react-router-dom';
import { supabase, supabaseAdmin } from '../lib/supabaseClient';
import { isValidPhoneNumber, isValidPostalCode } from '../utils/validation';
import { Product, PackageOption } from '../types';
import { useAuth } from '../context/AuthContext';

interface CheckoutDisplayItem extends Product {
  packageOption: PackageOption;
  quantity: number;
}

interface PostalCodeSuggestion {
  code: string;
  city: string;
}

// Define states for the overall checkout flow
type CheckoutStep = 'selection' | 'guest_form' | 'auth_form' | 'registration_form';
// Define states for auth flow within checkout (when 'auth_form' is active)
type AuthSubState = 'initial' | 'login' | 'signup' | 'loggedIn';

// Simple UUID v4 generator
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

export const CheckoutPage: React.FC = () => {
  const { cart, clearCart } = useCart();
  const { t, i18n } = useTranslation();
  const navigate = useNavigate();
  const { user, signInWithPassword, signUp, checkEmailExists } = useAuth();

  const [cartItemsDetails, setCartItemsDetails] = useState<CheckoutDisplayItem[]>([]);
  const [loadingDetails, setLoadingDetails] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [formErrors, setFormErrors] = useState<{[key: string]: string | null}>({}); // General/Submission errors
  const [authError, setAuthError] = useState<string | null>(null); // Specific auth errors
  const [paymentMethod, setPaymentMethod] = useState<string>('delivery');
  const [showPassword, setShowPassword] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    phone: '',
    address: '',
    city: '',
    postalCode: '',
    country: 'Slovenija',
    notes: '',
    password: '',
    confirmPassword: '',
  });

  // New state for managing checkout steps
  const [checkoutStep, setCheckoutStep] = useState<CheckoutStep>('selection');
  // State for managing login/signup within the auth path
  const [authSubState, setAuthSubState] = useState<AuthSubState>('initial');

  const [emailToCheck, setEmailToCheck] = useState<string>('');
  const [checkingEmail, setCheckingEmail] = useState<boolean>(false);
  


  const [postalSuggestions, setPostalSuggestions] = useState<PostalCodeSuggestion[]>([]);

  const commonPostalCodes: PostalCodeSuggestion[] = [
    { code: "1000", city: "Ljubljana" },
    { code: "2000", city: "Maribor" },
    { code: "3000", city: "Celje" },
    { code: "4000", city: "Kranj" },
    { code: "5000", city: "Nova Gorica" },
    { code: "6000", city: "Koper" }
  ];

  // Effect to handle cart items and fetch product details
  useEffect(() => {
    const fetchCartItemDetails = async () => {
      if (cart.length === 0) {
        setCartItemsDetails([]);
        setLoadingDetails(false);
        return;
      }

      setLoadingDetails(true);
      try {
        // Get all product IDs from cart
        const productIds = [...new Set(cart.map(item => item.productId))];
        
        // Fetch products data
        const { data: productsData, error } = await supabase
          .from('products')
          .select('*')
          .in('id', productIds);
        
        if (error) {
          console.error('Error fetching products:', error);
          setError(t('checkout.errors.productFetchFailed', 'Failed to load product details.'));
          setLoadingDetails(false);
          return;
        }

        // Map cart items to display items with full product details
        const displayItems: CheckoutDisplayItem[] = cart.map(cartItem => {
          const product = productsData.find(p => p.id === cartItem.productId);
          if (!product) {
            console.error(`Product not found for ID: ${cartItem.productId}`);
            return null;
          }

          // Find the selected package option
          const packageOptions = typeof product.package_options === 'string' 
            ? JSON.parse(product.package_options) 
            : product.package_options;
          
          const packageOption = packageOptions.find((opt: PackageOption) => 
            opt.uniq_id === cartItem.packageOptionId
          );

          if (!packageOption) {
            console.error(`Package option not found for ID: ${cartItem.packageOptionId}`);
            return null;
          }

          return {
            ...product,
            packageOption,
            quantity: cartItem.quantity
          };
        }).filter(Boolean) as CheckoutDisplayItem[];

        setCartItemsDetails(displayItems);
      } catch (err) {
        console.error('Error processing cart items:', err);
        setError(t('checkout.errors.cartProcessingFailed', 'Failed to process cart items.'));
      } finally {
        setLoadingDetails(false);
      }
    };

    fetchCartItemDetails();
  }, [cart, t]);

  // Effect to set the appropriate checkout step when user is logged in
  useEffect(() => {
    if (user && checkoutStep === 'selection') {
      setCheckoutStep('guest_form');
      
      // Fetch user profile data to pre-fill the form
      const fetchUserProfile = async () => {
        try {
          const { data, error } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', user.id)
            .single();
          
          if (error) {
            console.error('Error fetching user profile:', error);
            return;
          }
          
          if (data) {
            console.log('User profile data:', data);
            
            // Safely extract shipping address data
            let addressData = {
              address: '',
              city: '',
              postalCode: '',
              country: 'Slovenija'
            };
            
            try {
              if (data.default_shipping_address) {
                const parsedAddress = typeof data.default_shipping_address === 'string' 
                  ? JSON.parse(data.default_shipping_address)
                  : data.default_shipping_address;
                
                addressData = {
                  address: parsedAddress.address || '',
                  city: parsedAddress.city || '',
                  postalCode: parsedAddress.postalCode || parsedAddress.postal_code || '',
                  country: parsedAddress.country || 'Slovenija'
                };
              }
            } catch (parseErr) {
              console.error('Error parsing shipping address:', parseErr);
            }
            
            setFormData(prev => ({
              ...prev,
              name: data.full_name || '',
              email: user.email || '',
              phone: data.telephone_nr || '',
              address: addressData.address,
              city: addressData.city,
              postalCode: addressData.postalCode,
              country: addressData.country,
            }));
          }
        } catch (err) {
          console.error('Exception fetching user profile:', err);
        }
      };
      
      fetchUserProfile();
    }
  }, [user, checkoutStep]);

  const handleInputChange = (nameOrEvent: string | React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>, valueParam?: string) => {
    // Handle both direct calls and event-based calls
    let name: string;
    let value: string;
    
    if (typeof nameOrEvent === 'string') {
      // Direct call with name and value
      name = nameOrEvent;
      value = valueParam || '';
    } else {
      // Event-based call
      name = nameOrEvent.target.name;
      value = nameOrEvent.target.value;
    }

    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Show postal code suggestions
    if (name === 'postalCode') {
      const suggestions = value ? commonPostalCodes.filter(p => 
        p.code.startsWith(value) || p.city.toLowerCase().includes(value.toLowerCase())
      ) : [];
      setPostalSuggestions(suggestions);
      
      // Auto-fill city when selecting from postal suggestions
      const match = commonPostalCodes.find(p => p.code === value);
      if (match) {
        setFormData(prev => ({ ...prev, city: match.city }));
        setPostalSuggestions([]);
      }
    }

    // Field validation
    if (name === 'phone') {
      // Only validate if there's a value (don't show error for empty field)
      if (value && !isValidPhoneNumber(value)) {
        setFormErrors(prev => ({
          ...prev,
          phone: t('checkout.errors.invalidPhone', 'Prosimo, vnesite veljavno telefonsko številko.')
        }));
      } else {
        setFormErrors(prev => ({ ...prev, phone: null }));
      }
    } else if (name === 'email') {
      // Email validation
      if (value && !/\S+@\S+\.\S+/.test(value)) {
        setFormErrors(prev => ({
          ...prev,
          email: t('checkout.errors.invalidEmail', 'Prosimo, vnesite veljaven email naslov.')
        }));
      } else {
        setFormErrors(prev => ({ ...prev, email: null }));
      }
    } else if (name === 'postalCode') {
      // Postal code validation
      if (value && !isValidPostalCode(value)) {
        setFormErrors(prev => ({
          ...prev,
          postalCode: t('checkout.errors.invalidPostalCode', 'Prosimo, vnesite veljavno poštno številko.')
        }));
      } else {
        setFormErrors(prev => ({ ...prev, postalCode: null }));
      }
    }

    // If email changes during auth flow, reset sub-state and trigger check
    if (name === 'email' && checkoutStep === 'auth_form' && authSubState !== 'loggedIn') {
       setAuthSubState('initial');
       setAuthError(null); // Clear previous auth errors
       setEmailToCheck(value); // Set email to be checked on blur/submit
    }
     if (name === 'password') {
       setAuthError(null); // Clear auth error when password changes
     }
  };

   const handleEmailBlur = useCallback(async () => {
     // Only check email if in the auth flow and not already logged in
     if (checkoutStep !== 'auth_form' || authSubState === 'loggedIn' || !emailToCheck || checkingEmail) {
       return;
     }
     setCheckingEmail(true);
     setAuthError(null);
     try {
       const exists = await checkEmailExists(emailToCheck);
       if (exists) {
         setAuthSubState('login');
       } else {
         if (/\S+@\S+\.\S+/.test(emailToCheck)) {
            setAuthSubState('signup');
         } else {
            setAuthSubState('initial'); // Invalid email format
         }
       }
     } catch (e) {
       console.error("Email check failed:", e);
       setAuthError(t('checkout.errors.emailCheckFailed', 'Could not verify email. Please try again.'));
       setAuthSubState('initial'); // Reset on error
     } finally {
       setCheckingEmail(false);
     }
   }, [emailToCheck, checkEmailExists, checkoutStep, authSubState, checkingEmail, t]);

  // Add a handler for payment method changes
  const handlePaymentChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setPaymentMethod(e.target.value);
  };

  const calculateSubtotal = () => {
    return cartItemsDetails.reduce((total, item) => {
      const price = item.packageOption?.price ?? 0;
      return total + price * item.quantity;
    }, 0);
  };

  const subtotal = calculateSubtotal();

  // Separate handler for Login/Signup actions before placing order
  const handleAuthAction = async (action: 'login' | 'signup') => {
     setAuthError(null);
     setIsSubmitting(true);

     try {
       if (action === 'login') {
         if (!formData.email || !formData.password) {
           setAuthError(t('checkout.errors.emailPasswordRequired', 'Email and password are required.'));
           setIsSubmitting(false);
           return;
         }

         const { error: loginError } = await signInWithPassword({
           email: formData.email,
           password: formData.password
         });

         if (loginError) {
           console.error('Login error:', loginError);
           setAuthError(t('checkout.errors.loginFailed', 'Login failed. Please check your credentials.'));
           setIsSubmitting(false);
           return;
         }

         // After successful login, fetch user profile data
         const fetchUserProfile = async () => {
           try {
             // Get the current user after successful login
             const { data: { user: currentUser } } = await supabase.auth.getUser();
             if (!currentUser) {
               console.error('No user found after login');
               return;
             }

             const { data, error } = await supabase
               .from('profiles')
               .select('*')
               .eq('id', currentUser.id)
               .single();
             
             if (error) {
               console.error('Error fetching user profile:', error);
               return;
             }
             
             if (data) {
               console.log('User profile data:', data);
               
               // Safely extract shipping address data
               let addressData = {
                 address: '',
                 city: '',
                 postalCode: '',
                 country: 'Slovenija'
               };
               
               try {
                 if (data.default_shipping_address) {
                   const parsedAddress = typeof data.default_shipping_address === 'string' 
                     ? JSON.parse(data.default_shipping_address)
                     : data.default_shipping_address;
                   
                   addressData = {
                     address: parsedAddress.address || '',
                     city: parsedAddress.city || '',
                     postalCode: parsedAddress.postalCode || parsedAddress.postal_code || '',
                     country: parsedAddress.country || 'Slovenija'
                   };
                 }
               } catch (parseErr) {
                 console.error('Error parsing shipping address:', parseErr);
               }
               
               setFormData(prev => ({
                 ...prev,
                 name: data.full_name || '',
                 email: currentUser.email || '',
                 phone: data.telephone_nr || '',
                 address: addressData.address,
                 city: addressData.city,
                 postalCode: addressData.postalCode,
                 country: addressData.country,
               }));
             }
           } catch (err) {
             console.error('Exception fetching user profile:', err);
           }
         };
         
         await fetchUserProfile();
         setAuthSubState('loggedIn');
         setCheckoutStep('guest_form');
         
       } else if (action === 'signup') {
         // Validate signup form
         if (!formData.email || !formData.password || !formData.confirmPassword) {
           setAuthError(t('checkout.errors.allFieldsRequired', 'All fields are required.'));
           setIsSubmitting(false);
           return;
         }

         if (formData.password !== formData.confirmPassword) {
           setAuthError(t('checkout.errors.passwordsDoNotMatch', 'Passwords do not match.'));
           setIsSubmitting(false);
           return;
         }

         // Phone number validation
         if (formData.phone && !isValidPhoneNumber(formData.phone)) {
           setAuthError(t('checkout.errors.invalidPhone', 'Prosimo, vnesite veljavno telefonsko številko.'));
           setIsSubmitting(false);
           return;
         }

         // Create user with Supabase Auth
         const { error: signupError } = await signUp({
           email: formData.email,
           password: formData.password,
           options: {
             data: {
               full_name: formData.name,
               default_shipping_address: JSON.stringify({
                 address: formData.address,
                 city: formData.city,
                 postalCode: formData.postalCode,
                 country: formData.country,
               }),
             }
           }
         });

         if (signupError) {
           setAuthError(signupError.message);
           setIsSubmitting(false);
           return;
         }

         // Signup successful, state will change via onAuthStateChange listener
         setAuthSubState('loggedIn');
         // After successful registration, show the checkout form
         setCheckoutStep('guest_form');
       }

     // Clear errors and set loading state
     setIsSubmitting(false);
     setError(null); // Clear any previous general errors
     
   } catch (err: any) {
     console.error("Auth action error:", err);
     setAuthError(err.message || t('checkout.errors.authFailed', 'Authentication failed. Please try again.'));
     setIsSubmitting(false);
   }
  };

  // Form validation function
  const validateForm = () => {
    // Reset form errors
    const newFormErrors: {[key: string]: string | null} = {};
    
    // Validate required fields
    if (!formData.name) newFormErrors.name = t('checkout.errors.nameRequired', 'Name is required');
    if (!formData.email) newFormErrors.email = t('checkout.errors.emailRequired', 'Email is required');
    if (!formData.phone) newFormErrors.phone = t('checkout.errors.phoneRequired', 'Phone number is required');
    if (!formData.address) newFormErrors.address = t('checkout.errors.addressRequired', 'Address is required');
    if (!formData.city) newFormErrors.city = t('checkout.errors.cityRequired', 'City is required');
    if (!formData.postalCode) newFormErrors.postalCode = t('checkout.errors.postalCodeRequired', 'Postal code is required');
    
    // Validate email format
    if (formData.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newFormErrors.email = t('checkout.errors.invalidEmail', 'Please enter a valid email address');
    }
    
    // Validate phone number
    if (formData.phone && !isValidPhoneNumber(formData.phone)) {
      newFormErrors.phone = t('checkout.errors.invalidPhone', 'Please enter a valid phone number');
    }
    
    // Validate postal code
    if (formData.postalCode && !isValidPostalCode(formData.postalCode)) {
      newFormErrors.postalCode = t('checkout.errors.invalidPostalCode', 'Please enter a valid postal code');
    }
    
    // Update form errors state
    setFormErrors(newFormErrors);
    
    // Return general error message if any errors exist
    const hasErrors = Object.values(newFormErrors).some(error => error !== null);
    if (hasErrors) {
      return t('checkout.errors.formValidation', 'Please correct the errors in the form');
    }
    
    return null; // No errors
  };

  // Refactored order placement logic
  const placeOrder = async () => {
    setError(null);
    setAuthError(null); // Clear auth errors before placing order attempt

    const validationError = validateForm();
    if (validationError) {
      setError(validationError);
      return;
    }

    if (!paymentMethod) {
      setError(t('checkout.errorPaymentMethodRequired', 'Please select a payment method.'));
      return;
    }
     if (cart.length === 0 || loadingDetails) {
      setError(t('checkout.submitErrorCartEmpty', 'Cannot proceed with an empty cart.'));
      return;
    }

    setIsSubmitting(true); // Set submitting true only when starting the actual order placement

    // Ensure we have the latest user ID right before submission
    // Re-fetch user state directly from supabase client just in case context is stale
    const { data: { user: currentUser } = { user: null } } = await supabase.auth.getUser();
    const currentUserId = currentUser?.id || null;
    const isGuest = !currentUserId;

    // Double-check email consistency if logged in
    if (currentUser && currentUser.email !== formData.email) {
        console.warn("Form email differs from logged-in user email. Using logged-in user's email.");
        // Optionally update formData.email or notify user, for now proceed with currentUser.email
    }


    try {
      // 1. Find or Create Profile
      let profileId: string | null = null;

      if (currentUserId) {
          // User is logged in
          const { data: userProfile, error: profileFetchError } = await supabase
              .from('profiles')
              .select('id, full_name, telephone_nr, default_shipping_address') // Updated to match schema
              .eq('id', currentUserId)
              .maybeSingle();

          if (profileFetchError) throw new Error(`Profile lookup failed: ${profileFetchError.message}`);

          if (userProfile) {
              profileId = userProfile.id;
              console.log('Found profile for logged-in user:', profileId);
              // Update profile if form data is different (optional, consider UX)
              // Example: Check if formData.name is different and update
              // For now, we just use the existing profile ID.
              // Pre-fill form with profile data if it wasn't already done (e.g., if they logged in during checkout)
              if (!formData.name && userProfile.full_name) setFormData(prev => ({ ...prev, name: userProfile.full_name }));
              if (!formData.phone && userProfile.telephone_nr) setFormData(prev => ({ ...prev, phone: userProfile.telephone_nr }));
              // TODO: Parse and pre-fill address from userProfile.default_shipping_address if needed

          } else {
              // Logged-in user has no profile yet (e.g., signed up but didn't complete checkout before)
              console.log('Creating profile for logged-in user:', currentUserId);
              if (supabaseAdmin) {
                console.log("Creating profile with data:", {
                  id: currentUserId,
                  username: formData.email,
                  full_name: formData.name,
                  email: formData.email,
                  telephone_nr: formData.phone,
                  default_shipping_address: {
                    address: formData.address,
                    city: formData.city,
                    postalCode: formData.postalCode,
                    country: formData.country,
                  }
                });
                
                try {
                  // Create or update profile
                  const { error: profileError } = await supabaseAdmin.from('profiles')
                    .upsert({
                      id: currentUserId,
                      username: formData.email,
                      full_name: formData.name,
                      email: formData.email,
                      telephone_nr: formData.phone,
                      default_shipping_address: JSON.stringify({
                        address: formData.address,
                        city: formData.city,
                        postalCode: formData.postalCode,
                        country: formData.country,
                      }),
                    }, { onConflict: 'id' });
                    
                  if (profileError) {
                    console.error("Error creating/updating profile:", profileError);
                    throw new Error(`Profile creation/update failed: ${profileError.message}`);
                  } else {
                    console.log("Profile created/updated successfully");
                    profileId = currentUserId;
                  }
                } catch (err) {
                  console.error("Error in profile operation:", err);
                  throw err;
                }
              } else {
                console.error("Admin client not available for profile creation");
                throw new Error("Admin client not available for profile creation");
              }
          }
      } else {
          // Guest checkout
          console.log('Processing guest checkout for email:', formData.email);
          if (!supabaseAdmin) {
              throw new Error('Admin client not available for guest profile creation');
          }

          // Check if a profile exists with this email
          const { data: existingProfile, error: guestProfileError } = await supabaseAdmin
              .from('profiles')
              .select('id')
              .eq('email', formData.email)
              .maybeSingle();

          if (guestProfileError) throw new Error(`Guest profile lookup failed: ${guestProfileError.message}`);

          if (existingProfile) {
              // Found an existing profile. Reuse it.
              profileId = existingProfile.id;
              console.log('Found existing profile:', profileId);
              // Update profile details
              const { error: updateError } = await supabaseAdmin
                  .from('profiles')
                  .update({
                    full_name: formData.name,
                    telephone_nr: formData.phone,
                    default_shipping_address: JSON.stringify({
                      address: formData.address,
                      city: formData.city,
                      postalCode: formData.postalCode,
                      country: formData.country,
                    }),
                  })
                  .eq('id', profileId);
              
              if (updateError) throw new Error(`Failed to update profile: ${updateError.message}`);
          } else {
              // Create a new profile
              console.log('Creating new profile for email:', formData.email);
              const guestUUID = generateUUID();
              const { data: newProfile, error: insertProfileError } = await supabaseAdmin
                  .from('profiles')
                  .insert({
                    id: guestUUID,
                    username: formData.email,
                    full_name: formData.name,
                    email: formData.email,
                    telephone_nr: formData.phone,
                    default_shipping_address: JSON.stringify({
                      address: formData.address,
                      city: formData.city,
                      postalCode: formData.postalCode,
                      country: formData.country,
                    }),
                  })
                  .select('id')
                  .single();

              if (insertProfileError) throw new Error(`Profile creation failed: ${insertProfileError.message}`);
              if (!newProfile) throw new Error('Profile creation returned no data.');
              profileId = newProfile.id;
              console.log('Created new profile:', profileId);
          }
      }


      if (!profileId) {
        throw new Error('Failed to obtain profile ID.');
      }

      // 2. Prepare Order Data
      const orderItems = cartItemsDetails.map((item: CheckoutDisplayItem) => ({
        product_id: item.id,
        product_name: item[`name_${i18n.language}` as keyof Product] || item.name,
        package_option_id: item.packageOption.uniq_id,
        package_description: item.packageOption.weight || item.packageOption.description || '',
        quantity: item.quantity,
        price_per_unit: item.packageOption.price,
        line_total: item.packageOption.price * item.quantity,
      }));

      const shippingAddress = {
        name: formData.name,
        address: formData.address,
        city: formData.city,
        postalCode: formData.postalCode,
        country: formData.country,
        phone: formData.phone,
        email: formData.email, // Include email in shipping address for confirmation emails etc.
      };

      // 3. Create Order
      console.log('Creating order with profile_id:', profileId, 'user_id:', currentUserId, 'is_guest:', isGuest);
      
      // Set initial status
      const initialStatus = 'processing';
      
      const { data: newOrder, error: orderError } = await supabase
        .from('orders')
        .insert({
          profile_id: profileId,
          total_price: subtotal,
          status: initialStatus,
          items: JSON.stringify(orderItems),
          shipping_address: JSON.stringify(shippingAddress),
          notes: formData.notes,
          payment_method: paymentMethod,
          is_guest_order: isGuest,
          currency: 'EUR', 
        })
        .select('id')
        .single();

      if (orderError) throw new Error(`Order creation failed: ${orderError.message}`);
      if (!newOrder) throw new Error('Order creation returned no data.');

      console.log('Order created successfully:', newOrder.id);

      // 4. Update product stock quantities
      try {
        // For each item in the order, update the stock in the products table
        for (const item of cartItemsDetails) {
          // Get the current product data
          const { data: product, error: productError } = await supabase
            .from('products')
            .select('stock_quantity, package_options')
            .eq('id', item.id)
            .single();

          if (productError) {
            console.error(`Error fetching product ${item.id}:`, productError);
            continue; // Skip to next item if there's an error
          }

          if (!product) {
            console.error(`Product ${item.id} not found`);
            continue;
          }

          // Parse package options to check if the option exists
          let productPackageOptions;
          try {
            productPackageOptions = typeof product.package_options === 'string'
              ? JSON.parse(product.package_options)
              : product.package_options;
              
            // Verify the package option exists
            const packageOption = productPackageOptions.find((pkg: any) => 
              pkg.uniq_id === item.packageOption.uniq_id
            );

            if (!packageOption) {
              console.error(`Package option ${item.packageOption.uniq_id} not found for product ${item.id}`);
              continue;
            }
            
          } catch (e) {
            console.error(`Error parsing package options for product ${item.id}:`, e);
            continue;
          }

          // Calculate new stock value using stock_quantity field
          const currentStock = product.stock_quantity || 0;
          const newStock = Math.max(0, currentStock - item.quantity); // Ensure stock doesn't go below 0
          
          // Update the stock_quantity in the database
          const { error: updateError } = await supabase
            .from('products')
            .update({ stock_quantity: newStock })
            .eq('id', item.id);

          if (updateError) {
            console.error(`Error updating stock for product ${item.id}:`, updateError);
          } else {
            console.log(`Updated stock for product ${item.id} to ${newStock}`);
          }
  }
} catch (stockError: any) {
  // Log the error but don't fail the order - we've already created it
  console.error('Error updating stock quantities:', stockError);
}

      // Complete the order process
      clearCart();
      if (user) {
        console.log('Redirecting logged-in user to /orders');
        navigate('/orders');
      } else {
        console.log('Redirecting guest user to order confirmation');
        navigate(`/order-confirmation/${newOrder.id}`);
      }
    } catch (err: any) {
      console.error('Error placing order:', err);
      setError(err.message || t('checkout.genericError', 'An error occurred while placing your order.'));
    } finally {
      setIsSubmitting(false); // Ensure submitting is set to false after attempt
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      {loadingDetails ? (
        <div className="flex justify-center items-center h-64">
          <p className="text-lg text-gray-600">{t('checkout.loading', 'Loading checkout...')}</p>
        </div>
      ) : cart.length === 0 ? (
        <div className="text-center py-12">
          <h2 className="text-2xl font-bold mb-4">{t('checkout.emptyCart', 'Your cart is empty')}</h2>
          <p className="mb-6">{t('checkout.emptyCartMessage', 'Add some products to your cart before proceeding to checkout.')}</p>
          <button
            onClick={() => navigate('/products')}
            className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-brown-600 hover:bg-brown-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brown-500"
          >
            {t('checkout.continueShopping', 'Continue Shopping')}
          </button>
        </div>
      ) : (
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Checkout form content */}
          <div className="lg:col-span-2">
            <h2 className="text-2xl font-bold mb-6">{t('checkout.title', 'Checkout')}</h2>
            
            {/* Payment method selection */}
            <div className="mt-6 border-t pt-6">
              <h3 className="text-lg font-medium text-gray-900 mb-4">{t('checkout.paymentInfo', 'Payment Information')}</h3>
              <div className="mt-4">
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    {t('checkout.paymentMethod', 'Payment Method')}
                  </label>
                  <div className="mt-1 space-y-2">
                    <div className="flex items-center">
                      <input
                        id="payment-delivery"
                        name="payment-method"
                        type="radio"
                        checked={paymentMethod === 'delivery'}
                        onChange={() => setPaymentMethod('delivery')}
                        className="h-4 w-4 text-brown-600 focus:ring-brown-500 border-gray-300"
                      />
                      <label htmlFor="payment-delivery" className="ml-3 block text-sm text-gray-700">
                        {t('checkout.payOnDelivery', 'Pay on Delivery')}
                      </label>
                    </div>
                  </div>
                </div>
              </div>
              
              {/* Place Order Button */}
              <div className="mt-8 border-t pt-6">
                <button
                  onClick={placeOrder}
                  disabled={isSubmitting || cart.length === 0 || loadingDetails || !paymentMethod}
                  className={`w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-base font-medium text-white ${
                    isSubmitting || cart.length === 0 || loadingDetails || !paymentMethod
                    ? 'bg-gray-400 cursor-not-allowed'
                    : 'bg-brown-600 hover:bg-brown-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brown-500'
                  }`}
                >
                  {isSubmitting ? t('checkout.submitting', 'Processing...') : t('checkout.placeOrder', 'Place Order')}
                </button>
                {error && (
                  <p className="mt-2 text-sm text-red-600">{error}</p>
                )}
              </div>
            </div>
          </div>
          
          {/* Order Summary */}
          <div className="lg:col-span-1">
            <div className="bg-gray-50 p-6 rounded-lg shadow-sm">
              <h3 className="text-lg font-medium text-gray-900 mb-4">{t('checkout.orderSummary', 'Order Summary')}</h3>
              <div className="mt-4 border-t border-gray-200 pt-4">
                <div className="flex justify-between text-base font-medium text-gray-900">
                  <p>{t('checkout.subtotal', 'Subtotal')}</p>
                  <p>
                    {new Intl.NumberFormat('sl-SI', { style: 'currency', currency: 'EUR' }).format(subtotal)}
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
            </div>
          </div>
        </fieldset>
        <p className="mt-4 text-sm text-gray-600">
          {paymentMethod === 'delivery'
            ? t('checkout.paymentInstructions.payOnDelivery', 'Prosimo, da imate ob dostavi pripravljen točen znesek.')
            : t('checkout.paymentInstructions.selectMethod', 'Izberite način plačila zgoraj.')}
        </p>
              </div>

              {/* Place Order Button */}
              <div className="mt-8 border-t pt-6">
                {/* The main submit button now always says "Place Order" when visible */}
                {/* We disable it if the user needs to login/signup first */}
                <button
                  type="submit"
                  disabled={
                    isSubmitting ||
                    cart.length === 0 ||
                    loadingDetails ||
                    !paymentMethod ||
                    checkingEmail ||
                    (checkoutStep === 'auth_form' && (authSubState === 'login' || authSubState === 'signup')) // Disable if login/signup is pending
                  }
                  className={`w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-base font-medium text-white ${
                    isSubmitting || cart.length === 0 || loadingDetails || !paymentMethod || checkingEmail || (checkoutStep === 'auth_form' && (authSubState === 'login' || authSubState === 'signup'))
                    ? 'bg-gray-400 cursor-not-allowed'
                    : 'bg-brown-600 hover:bg-brown-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brown-500'
                  }`}
                >
                  {isSubmitting ? t('checkout.submitting', 'Oddajanje naročila...') : t('checkout.placeOrder', 'Oddaj naročilo')}
                </button>
                {/* Inform user they need to login/signup first if button is disabled for that reason */}
                {checkoutStep === 'auth_form' && (authSubState === 'login' || authSubState === 'signup') && !isSubmitting && (
                    <p className="text-center text-sm text-red-600 mt-2">
                        {authSubState === 'login' ? t('checkout.errors.mustLoginFirst', 'Prosimo, prijavite se pred oddajo naročila.') : t('checkout.errors.mustSignupFirst', 'Prosimo, registrirajte se pred oddajo naročila.')}
                    </p>
                )}
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
};
