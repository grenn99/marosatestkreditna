import React, { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { supabase } from '../lib/supabaseClient';

interface PackageOption {
  uniq_id: string;
  price: number;
  weight?: string;
  description?: string;
  stock: number | null; // Allow null values for stock as seen in the database
  isActive: boolean;
}

interface Product {
  id: number;
  name: string;
  name_en: string;
  name_de: string;
  name_hr: string;
  description: string;
  description_en: string;
  description_de: string;
  description_hr: string;
  image_url: string;
  isActive: boolean;
  stock_quantity: number;
  package_options: PackageOption[];
  category: string;
  price: number | null;
}

export const AdminProductsPage: React.FC = () => {
  const { t, i18n } = useTranslation();
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  // We're using loading state instead of isSubmitting
  const [error, setError] = useState<string | null>(null);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null); 
  const [editFormData, setEditFormData] = useState<Partial<Product>>({});
  const [showAddProductModal, setShowAddProductModal] = useState(false);
  const [newProductData, setNewProductData] = useState<Partial<Product>>({}); 

  const fetchProducts = async () => {
    try {
      const { data, error } = await supabase
        .from('products')
        .select('*');

      if (error) throw error;

      const productsWithParsedOptions = data.map((product: any) => ({
        ...product,
        stock_quantity: product.stock_quantity || 0,
        package_options: typeof product.package_options === 'string' 
          ? JSON.parse(product.package_options) 
          : product.package_options
      }));

      setProducts(productsWithParsedOptions);
    } catch (err: any) {
      console.error('Error fetching products:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchProducts();
  }, []);

  useEffect(() => {
    if (editingProduct) {
      setEditFormData({
        name: editingProduct.name,
        name_en: editingProduct.name_en,
        description: editingProduct.description,
        description_en: editingProduct.description_en,
        image_url: editingProduct.image_url,
        id: editingProduct.id, 
        isActive: editingProduct.isActive,
        package_options: editingProduct.package_options ? [...editingProduct.package_options] : [], // Ensure it's a mutable copy
        stock_quantity: editingProduct.stock_quantity
      });
    } else {
      setEditFormData({}); 
    }
  }, [editingProduct]);
  
  // Function to get the next available product ID
  const getNextProductId = async () => {
    try {
      // Get all product IDs to ensure we don't create a duplicate
      const { data, error } = await supabase
        .from('products')
        .select('id');

      if (error) throw error;

      // If there are no products yet, start with ID 1
      if (!data || data.length === 0) {
        return 1;
      }

      // Convert all IDs to numbers and find the highest one
      const existingIds = data.map(product => parseInt(product.id));
      const highestId = Math.max(...existingIds);
      
      // Return the highest ID + 1
      return highestId + 1;
    } catch (err) {
      console.error('Error getting next product ID:', err);
      // Fallback to a timestamp-based ID if we can't get the next ID
      return Math.floor(Date.now() / 1000);
    }
  };
  
  // Function to check if an ID already exists in the database
  const checkIdExists = async (id: number | undefined) => {
    if (id === undefined) return false; // Handle undefined case
    try {
      const { data, error } = await supabase
        .from('products')
        .select('id')
        .eq('id', id)
        .single();

      if (error && error.code === 'PGRST116') {
        // PGRST116 means no rows returned, so ID doesn't exist
        return false;
      }

      // If we got data back, the ID exists
      return !!data;
    } catch (err) {
      console.error('Error checking if ID exists:', err);
      // If there's an error, assume ID might exist to be safe
      return true;
    }
  };

  // Reset new product form when modal is opened
  useEffect(() => {
    const initializeNewProduct = async () => {
      if (showAddProductModal) {
        try {
          // Get the next available ID when the modal is opened
          let nextId = await getNextProductId();
          
          // Double-check that this ID doesn't already exist
          let idExists = await checkIdExists(nextId);
          
          // If ID exists, keep incrementing until we find an available one
          while (idExists) {
            nextId++;
            idExists = await checkIdExists(nextId);
          }
          
          console.log('Using new product ID:', nextId);
          
          setNewProductData({
            id: nextId,
            name: '',
            name_en: '',
            name_de: '',
            name_hr: '',
            description: '',
            description_en: '',
            description_de: '',
            description_hr: '',
            image_url: '',
            isActive: true,
            stock_quantity: 100, // Default to 100 as seen in the examples
            category: 'Default',
            package_options: [{ 
              uniq_id: `${nextId}-0`, 
              price: 0, 
              stock: null as number | null, // Explicitly cast to number | null
              isActive: true, 
              description: '', 
              weight: '' 
            }]
          });
        } catch (err) {
          console.error('Error initializing new product:', err);
          // Use a fallback ID based on timestamp if all else fails
          const fallbackId = Math.floor(Date.now() / 1000);
          setNewProductData({
            id: fallbackId,
            name: '',
            name_en: '',
            name_de: '',
            name_hr: '',
            description: '',
            description_en: '',
            description_de: '',
            description_hr: '',
            image_url: '',
            isActive: true,
            stock_quantity: 100,
            category: 'Default',
            package_options: [{ 
              uniq_id: `${fallbackId}-0`, 
              price: 0, 
              stock: null as number | null,
              isActive: true, 
              description: '', 
              weight: '' 
            }]
          });
        }
      }
    };
    
    initializeNewProduct();
  }, [showAddProductModal]);

  const handleFormChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setEditFormData(prev => ({ ...prev, [name]: value }));
  };

  // Handle changes specifically within a package option input
  const handlePackageChange = (index: number, e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value, type, checked } = e.target;
    const updatedValue = type === 'checkbox' ? checked : type === 'number' ? parseFloat(value) || 0 : value;

    setEditFormData(prev => {
      if (!prev.package_options) return prev; // Should not happen, but type safety
      const newPackages = [...prev.package_options];
      newPackages[index] = { ...newPackages[index], [name]: updatedValue };
      return { ...prev, package_options: newPackages };
    });
  };

  // Add a new blank package option to the form
  const addPackageOption = () => {
    setEditFormData(prev => ({
      ...prev,
      package_options: [
        ...(prev.package_options || []),
        { uniq_id: `new_${Date.now()}`, price: 0, stock: 0, isActive: true, description: '', weight: '' } // Default new package
      ]
    }));
  };

  // Remove a package option from the form by index
  const removePackageOption = (index: number) => {
    setEditFormData(prev => {
      if (!prev.package_options) return prev;
      const newPackages = prev.package_options.filter((_, i) => i !== index);
      return { ...prev, package_options: newPackages };
    });
  };

  const handleNewProductChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setNewProductData(prev => ({ ...prev, [name]: value }));
  };

  // Handle changes specifically within a package option input for new product
  const handleNewProductPackageChange = (index: number, e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value, type, checked } = e.target;
    const updatedValue = type === 'checkbox' ? checked : type === 'number' ? parseFloat(value) || 0 : value;

    setNewProductData(prev => {
      if (!prev.package_options) return prev; // Should not happen, but type safety
      const newPackages = [...prev.package_options];
      newPackages[index] = { ...newPackages[index], [name]: updatedValue };
      return { ...prev, package_options: newPackages };
    });
  };

  // Add a new blank package option to the new product form
  const addNewProductPackageOption = () => {
    setNewProductData(prev => {
      const newIndex = prev.package_options ? prev.package_options.length : 0;
      return {
        ...prev,
        package_options: [
          ...(prev.package_options || []),
          { 
            uniq_id: `${prev.id}-${newIndex}`, // Use product ID + index for package ID (matches format in SQL)
            price: 0, 
            stock: null as number | null, // Explicitly cast to number | null to satisfy TypeScript
            isActive: true, 
            description: '', 
            weight: '' 
          } // Default new package
        ]
      };
    });
  };

  // Remove a package option from the new product form by index
  const removeNewProductPackageOption = (index: number) => {
    setNewProductData(prev => {
      if (!prev.package_options) return prev;
      const newPackages = prev.package_options.filter((_, i) => i !== index);
      return { ...prev, package_options: newPackages };
    });
  };
  }
};

// Shorthand functions for specific languages
const translateToEnglish = (text: string) => translateText(text, 'en');
const translateToGerman = (text: string) => translateText(text, 'de');
const translateToCroatian = (text: string) => translateText(text, 'hr');

// Function to translate all fields of a product
const translateAllProductFields = async (product: Partial<Product>) => {
  if (!product.name) {
    alert('Slovenian product name is required for translation!');
    return product;
  }

  try {
    setLoading(true);

    // Translate to all languages in parallel
    const [nameEn, nameDe, nameHr, descEn, descDe, descHr] = await Promise.all([
      translateToEnglish(product.name),
      translateToGerman(product.name),
      translateToCroatian(product.name),
      product.description ? translateToEnglish(product.description) : '',
      product.description ? translateToGerman(product.description) : '',
      product.description ? translateToCroatian(product.description) : ''
    ]);

    return {
      ...product,
      name_en: nameEn,
      name_de: nameDe,
      name_hr: nameHr,
      description_en: descEn,
      description_de: descDe,
      description_hr: descHr
    };
  } catch (error) {
    console.error('Error translating product fields:', error);
    alert('Failed to translate product fields. Please try again.');
    return product;
  } finally {
    setLoading(false);
  }
};

// ... (rest of the code remains the same)

// Add New Product Modal
{showAddProductModal && (
  <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center p-4 z-50">
    <div className="bg-white rounded-lg shadow-2xl p-8 w-full max-w-3xl max-h-[90vh] overflow-y-auto">
      <h2 className="text-2xl font-bold mb-6 text-brown-800 border-b border-gray-200 pb-3">{t('admin.productManagement.addNewProduct', 'Add New Product')}</h2>

      <div className="grid grid-cols-1 gap-6 mb-6">
        <div className="mb-4">
          <div className="flex justify-between items-center mb-2">
            <label className="block text-gray-700 text-sm font-bold">
              {t('admin.productManagement.nameEn', 'Product Name (English)')}
            </label>
            <button
              type="button"
              onClick={async () => {
                if (!newProductData.name) {
                  alert('Please enter a Slovenian name first');
                  return;
                }
                const translated = await translateToEnglish(newProductData.name);
                setNewProductData({...newProductData, name_en: translated});
              }}
              className="text-xs bg-blue-500 hover:bg-blue-700 text-white py-1 px-2 rounded"
            >
              {t('admin.productManagement.translate', 'Translate')}
            </button>
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default AdminProductsPage;
