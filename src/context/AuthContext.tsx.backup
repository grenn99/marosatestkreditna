import React, { createContext, useState, useEffect, useContext, ReactNode } from 'react';
import { Session, User, AuthError, SignInWithPasswordCredentials, SignUpWithPasswordCredentials } from '@supabase/supabase-js';
import { supabase } from '../lib/supabaseClient'; // Your Supabase client instance

interface AuthContextType {
  session: Session | null;
  user: User | null;
  loading: boolean;
  signOut: () => Promise<void>;
  signInWithPassword: (credentials: SignInWithPasswordCredentials) => Promise<{ error: AuthError | null }>;
  signUp: (credentials: SignUpWithPasswordCredentials) => Promise<{ error: AuthError | null }>;
  checkEmailExists: (email: string) => Promise<boolean>; // Added email check utility
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [session, setSession] = useState<Session | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Fetch initial session
    const fetchSession = async () => {
      setLoading(true); // Ensure loading is true at the start
      try {
        const { data: { session }, error } = await supabase.auth.getSession();
        if (error) {
          console.error("Error fetching session:", error.message);
        }
        setSession(session);
        setUser(session?.user ?? null);
      } catch (e) {
        console.error("Exception fetching session:", e);
      } finally {
        setLoading(false); // Set loading false after fetch attempt
      }
    };

    fetchSession();

    // Listen for auth state changes
    const { data: authListener } = supabase.auth.onAuthStateChange(
      async (_event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
        // No need to set loading here, it reflects the current state
      }
    );

    // Cleanup listener on component unmount
    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  const signOut = async () => {
    setLoading(true);
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error("Error signing out:", error.message);
      // Potentially show user feedback
    }
    // State updates handled by onAuthStateChange listener
    setLoading(false); // Set loading false after sign out attempt
  };

  const signInWithPassword = async (credentials: SignInWithPasswordCredentials) => {
    setLoading(true);
    const { error } = await supabase.auth.signInWithPassword(credentials);
    if (error) {
      console.error("Sign in error:", error.message);
    }
    // State updates handled by onAuthStateChange listener
    setLoading(false);
    return { error };
  };

  const signUp = async (credentials: SignUpWithPasswordCredentials) => {
    setLoading(true);
    // Note: Supabase sends a confirmation email by default.
    // You might want to disable this in Supabase settings for testing
    // or handle the confirmation flow explicitly.
    const { data, error } = await supabase.auth.signUp(credentials);
    if (error) {
      console.error("Sign up error:", error.message, " বিস্তারিত Error:", error); // Added detailed error log
    } else {
      // Optionally auto-login user after successful sign up or wait for email confirmation
      console.log("Sign up successful, user data:", data.user);
      // The onAuthStateChange listener should pick up the new user session if auto-confirmed
    }
    setLoading(false);
    return { error };
  };

  // Utility function to check if an email exists (approximated)
  // WARNING: This is NOT a foolproof way to check email existence for security reasons.
  // A dedicated backend function or Supabase function might be better.
  // This approach tries to sign in with a dummy password, which isn't ideal.
  // A better approach might involve a Supabase Function or checking profiles table if emails are unique there.
  // For now, we'll use a placeholder logic. Replace with a secure method if possible.
  const checkEmailExists = async (email: string): Promise<boolean> => {
     // Placeholder: In a real app, use a secure backend check.
     // This is a simplified check against the profiles table assuming email is unique.
     console.warn("Using simplified email check. Replace with secure backend check if possible.");
     if (!email) return false;
     try {
       const { data, error } = await supabase
         .from('profiles')
         .select('id')
         .eq('email', email)
         .maybeSingle();

       if (error) {
         console.error("Error checking email in profiles:", error);
         return false; // Assume not exists on error
       }
       return !!data; // Return true if a profile with this email exists
     } catch (err) {
       console.error("Exception during email check:", err);
       return false;
     }
  };


  const value = {
    session,
    user,
    loading,
    signOut,
    signInWithPassword,
    signUp,
    checkEmailExists,
  };

  return (
    <AuthContext.Provider value={value}>
      {children} {/* Render children immediately, loading state handled internally */}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
